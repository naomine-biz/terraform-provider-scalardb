// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: proto/scalardb/scalardb-cluster.proto

package scalardb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	DistributedTransaction_Begin_FullMethodName    = "/scalardb.cluster.rpc.v1.DistributedTransaction/Begin"
	DistributedTransaction_Get_FullMethodName      = "/scalardb.cluster.rpc.v1.DistributedTransaction/Get"
	DistributedTransaction_Scan_FullMethodName     = "/scalardb.cluster.rpc.v1.DistributedTransaction/Scan"
	DistributedTransaction_Put_FullMethodName      = "/scalardb.cluster.rpc.v1.DistributedTransaction/Put"
	DistributedTransaction_Insert_FullMethodName   = "/scalardb.cluster.rpc.v1.DistributedTransaction/Insert"
	DistributedTransaction_Upsert_FullMethodName   = "/scalardb.cluster.rpc.v1.DistributedTransaction/Upsert"
	DistributedTransaction_Update_FullMethodName   = "/scalardb.cluster.rpc.v1.DistributedTransaction/Update"
	DistributedTransaction_Delete_FullMethodName   = "/scalardb.cluster.rpc.v1.DistributedTransaction/Delete"
	DistributedTransaction_Mutate_FullMethodName   = "/scalardb.cluster.rpc.v1.DistributedTransaction/Mutate"
	DistributedTransaction_Commit_FullMethodName   = "/scalardb.cluster.rpc.v1.DistributedTransaction/Commit"
	DistributedTransaction_Rollback_FullMethodName = "/scalardb.cluster.rpc.v1.DistributedTransaction/Rollback"
)

// DistributedTransactionClient is the client API for DistributedTransaction service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service that provides a distributed transaction capability for ScalarDB Cluster.
//
// First, you call `Begin` to initiate a transaction. Then, you can call `Get` and `Scan` to read
// records, `Put`, `Insert`, `Upsert`, `Update`, and `Mutate` to write records, and `Delete` and
// `Mutate` to delete records. To finalize the transaction, call `Commit`. Alternatively, you can
// call `Rollback` at any time before the transaction is committed to cancel it. By calling `Begin`,
// you receive a transaction ID in the response, which you can then use to call `Get`, `Scan`, `Put`
// , `Insert`, `Upsert`, `Update`, `Delete`, `Mutate`, `Commit`, and `Rollback`.
//
// Also, you can call `Get`, `Scan`, `Put`, `Insert`, `Upsert`, `Update`, `Delete`, `Mutate` without
// a transaction ID. In this case, the operation is executed within a one-shot transaction.
type DistributedTransactionClient interface {
	// Begins a transaction.
	Begin(ctx context.Context, in *BeginRequest, opts ...grpc.CallOption) (*BeginResponse, error)
	// Retrieves records.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Scans records.
	Scan(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (*ScanResponse, error)
	// Deprecated: Do not use.
	// Puts records.
	// This is deprecated As of release 3.13.0. Will be removed in release 5.0.0.
	Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error)
	// Inserts records.
	Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error)
	// Upserts records.
	Upsert(ctx context.Context, in *UpsertRequest, opts ...grpc.CallOption) (*UpsertResponse, error)
	// Updates records.
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	// Deletes records.
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// Mutates (puts, inserts, upserts, updates, and deletes) multiple records.
	Mutate(ctx context.Context, in *MutateRequest, opts ...grpc.CallOption) (*MutateResponse, error)
	// Commits a transaction.
	Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*CommitResponse, error)
	// Rolls back a transaction.
	Rollback(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error)
}

type distributedTransactionClient struct {
	cc grpc.ClientConnInterface
}

func NewDistributedTransactionClient(cc grpc.ClientConnInterface) DistributedTransactionClient {
	return &distributedTransactionClient{cc}
}

func (c *distributedTransactionClient) Begin(ctx context.Context, in *BeginRequest, opts ...grpc.CallOption) (*BeginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BeginResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Begin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionClient) Scan(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (*ScanResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScanResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Scan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *distributedTransactionClient) Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PutResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Put_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionClient) Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Insert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionClient) Upsert(ctx context.Context, in *UpsertRequest, opts ...grpc.CallOption) (*UpsertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Upsert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionClient) Mutate(ctx context.Context, in *MutateRequest, opts ...grpc.CallOption) (*MutateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MutateResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Mutate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionClient) Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*CommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommitResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Commit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionClient) Rollback(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RollbackResponse)
	err := c.cc.Invoke(ctx, DistributedTransaction_Rollback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DistributedTransactionServer is the server API for DistributedTransaction service.
// All implementations must embed UnimplementedDistributedTransactionServer
// for forward compatibility.
//
// Service that provides a distributed transaction capability for ScalarDB Cluster.
//
// First, you call `Begin` to initiate a transaction. Then, you can call `Get` and `Scan` to read
// records, `Put`, `Insert`, `Upsert`, `Update`, and `Mutate` to write records, and `Delete` and
// `Mutate` to delete records. To finalize the transaction, call `Commit`. Alternatively, you can
// call `Rollback` at any time before the transaction is committed to cancel it. By calling `Begin`,
// you receive a transaction ID in the response, which you can then use to call `Get`, `Scan`, `Put`
// , `Insert`, `Upsert`, `Update`, `Delete`, `Mutate`, `Commit`, and `Rollback`.
//
// Also, you can call `Get`, `Scan`, `Put`, `Insert`, `Upsert`, `Update`, `Delete`, `Mutate` without
// a transaction ID. In this case, the operation is executed within a one-shot transaction.
type DistributedTransactionServer interface {
	// Begins a transaction.
	Begin(context.Context, *BeginRequest) (*BeginResponse, error)
	// Retrieves records.
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// Scans records.
	Scan(context.Context, *ScanRequest) (*ScanResponse, error)
	// Deprecated: Do not use.
	// Puts records.
	// This is deprecated As of release 3.13.0. Will be removed in release 5.0.0.
	Put(context.Context, *PutRequest) (*PutResponse, error)
	// Inserts records.
	Insert(context.Context, *InsertRequest) (*InsertResponse, error)
	// Upserts records.
	Upsert(context.Context, *UpsertRequest) (*UpsertResponse, error)
	// Updates records.
	Update(context.Context, *UpdateRequest) (*UpdateResponse, error)
	// Deletes records.
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// Mutates (puts, inserts, upserts, updates, and deletes) multiple records.
	Mutate(context.Context, *MutateRequest) (*MutateResponse, error)
	// Commits a transaction.
	Commit(context.Context, *CommitRequest) (*CommitResponse, error)
	// Rolls back a transaction.
	Rollback(context.Context, *RollbackRequest) (*RollbackResponse, error)
	mustEmbedUnimplementedDistributedTransactionServer()
}

// UnimplementedDistributedTransactionServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDistributedTransactionServer struct{}

func (UnimplementedDistributedTransactionServer) Begin(context.Context, *BeginRequest) (*BeginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Begin not implemented")
}
func (UnimplementedDistributedTransactionServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDistributedTransactionServer) Scan(context.Context, *ScanRequest) (*ScanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scan not implemented")
}
func (UnimplementedDistributedTransactionServer) Put(context.Context, *PutRequest) (*PutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedDistributedTransactionServer) Insert(context.Context, *InsertRequest) (*InsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedDistributedTransactionServer) Upsert(context.Context, *UpsertRequest) (*UpsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upsert not implemented")
}
func (UnimplementedDistributedTransactionServer) Update(context.Context, *UpdateRequest) (*UpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedDistributedTransactionServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDistributedTransactionServer) Mutate(context.Context, *MutateRequest) (*MutateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mutate not implemented")
}
func (UnimplementedDistributedTransactionServer) Commit(context.Context, *CommitRequest) (*CommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedDistributedTransactionServer) Rollback(context.Context, *RollbackRequest) (*RollbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rollback not implemented")
}
func (UnimplementedDistributedTransactionServer) mustEmbedUnimplementedDistributedTransactionServer() {
}
func (UnimplementedDistributedTransactionServer) testEmbeddedByValue() {}

// UnsafeDistributedTransactionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DistributedTransactionServer will
// result in compilation errors.
type UnsafeDistributedTransactionServer interface {
	mustEmbedUnimplementedDistributedTransactionServer()
}

func RegisterDistributedTransactionServer(s grpc.ServiceRegistrar, srv DistributedTransactionServer) {
	// If the following call pancis, it indicates UnimplementedDistributedTransactionServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DistributedTransaction_ServiceDesc, srv)
}

func _DistributedTransaction_Begin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Begin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Begin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Begin(ctx, req.(*BeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Scan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Scan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Scan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Scan(ctx, req.(*ScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Put_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Put(ctx, req.(*PutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Insert(ctx, req.(*InsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Upsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Upsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Upsert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Upsert(ctx, req.(*UpsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Mutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MutateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Mutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Mutate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Mutate(ctx, req.(*MutateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Commit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Commit(ctx, req.(*CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransaction_Rollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionServer).Rollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransaction_Rollback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionServer).Rollback(ctx, req.(*RollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DistributedTransaction_ServiceDesc is the grpc.ServiceDesc for DistributedTransaction service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DistributedTransaction_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "scalardb.cluster.rpc.v1.DistributedTransaction",
	HandlerType: (*DistributedTransactionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Begin",
			Handler:    _DistributedTransaction_Begin_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DistributedTransaction_Get_Handler,
		},
		{
			MethodName: "Scan",
			Handler:    _DistributedTransaction_Scan_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _DistributedTransaction_Put_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _DistributedTransaction_Insert_Handler,
		},
		{
			MethodName: "Upsert",
			Handler:    _DistributedTransaction_Upsert_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _DistributedTransaction_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _DistributedTransaction_Delete_Handler,
		},
		{
			MethodName: "Mutate",
			Handler:    _DistributedTransaction_Mutate_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _DistributedTransaction_Commit_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _DistributedTransaction_Rollback_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/scalardb/scalardb-cluster.proto",
}

const (
	TwoPhaseCommitTransaction_Begin_FullMethodName    = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Begin"
	TwoPhaseCommitTransaction_Join_FullMethodName     = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Join"
	TwoPhaseCommitTransaction_Get_FullMethodName      = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Get"
	TwoPhaseCommitTransaction_Scan_FullMethodName     = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Scan"
	TwoPhaseCommitTransaction_Put_FullMethodName      = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Put"
	TwoPhaseCommitTransaction_Insert_FullMethodName   = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Insert"
	TwoPhaseCommitTransaction_Upsert_FullMethodName   = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Upsert"
	TwoPhaseCommitTransaction_Update_FullMethodName   = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Update"
	TwoPhaseCommitTransaction_Delete_FullMethodName   = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Delete"
	TwoPhaseCommitTransaction_Mutate_FullMethodName   = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Mutate"
	TwoPhaseCommitTransaction_Prepare_FullMethodName  = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Prepare"
	TwoPhaseCommitTransaction_Validate_FullMethodName = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Validate"
	TwoPhaseCommitTransaction_Commit_FullMethodName   = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Commit"
	TwoPhaseCommitTransaction_Rollback_FullMethodName = "/scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction/Rollback"
)

// TwoPhaseCommitTransactionClient is the client API for TwoPhaseCommitTransaction service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service that provides a two-phase commit transaction capability for ScalarDB Cluster.
// See also: https://github.com/scalar-labs/scalardb/blob/master/docs/two-phase-commit-transactions.md
//
// First, you call `Begin` to initiate a transaction if you are the coordinator process.
// Alternatively, if you are a participant process, you can call `Join` to take part in a
// transaction that the coordinator has already begun. Then, you can call `Get` and `Scan` to read
// records, `Put`, `Insert`, `Upsert`, `Update`, and `Mutate` to write records, and `Delete` and
// `Mutate` to delete records. To finalize the transaction, call `Prepare`, `Validate`, and then
// `Commit` in order. Alternatively, you can call `Rollback` at any time before the transaction is
// committed to cancel it. By calling `Begin` or `Join`, you receive a transaction ID in the
// response, which you can then use to call `Get`, `Scan`, `Put`, `Insert`, `Upsert`, `Update`,
// `Delete`, `Mutate`, `Prepare`, `Validate`, `Commit`, and `Rollback`.
//
// Also, you can call `Get`, `Scan`, `Put`, `Insert`, `Upsert`, `Update`, `Delete`, `Mutate` without
// a transaction ID. In this case, the operation is executed within a one-shot transaction.
type TwoPhaseCommitTransactionClient interface {
	// Begins a transaction.
	Begin(ctx context.Context, in *BeginRequest, opts ...grpc.CallOption) (*BeginResponse, error)
	// Joins a transaction.
	Join(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*JoinResponse, error)
	// Retrieves records.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Scans records.
	Scan(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (*ScanResponse, error)
	// Deprecated: Do not use.
	// Puts records.
	// This is deprecated As of release 3.13.0. Will be removed in release 5.0.0.
	Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error)
	// Inserts records.
	Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error)
	// Upserts records.
	Upsert(ctx context.Context, in *UpsertRequest, opts ...grpc.CallOption) (*UpsertResponse, error)
	// Updates records.
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	// Deletes records.
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// Mutates (puts, deletes, inserts, upserts, and updates) multiple records.
	Mutate(ctx context.Context, in *MutateRequest, opts ...grpc.CallOption) (*MutateResponse, error)
	// Prepares a transaction.
	Prepare(ctx context.Context, in *PrepareRequest, opts ...grpc.CallOption) (*PrepareResponse, error)
	// Validates a transaction.
	Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error)
	// Commits a transaction.
	Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*CommitResponse, error)
	// Rolls back a transaction.
	Rollback(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error)
}

type twoPhaseCommitTransactionClient struct {
	cc grpc.ClientConnInterface
}

func NewTwoPhaseCommitTransactionClient(cc grpc.ClientConnInterface) TwoPhaseCommitTransactionClient {
	return &twoPhaseCommitTransactionClient{cc}
}

func (c *twoPhaseCommitTransactionClient) Begin(ctx context.Context, in *BeginRequest, opts ...grpc.CallOption) (*BeginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BeginResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Begin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Join(ctx context.Context, in *JoinRequest, opts ...grpc.CallOption) (*JoinResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Join_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Scan(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (*ScanResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScanResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Scan_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *twoPhaseCommitTransactionClient) Put(ctx context.Context, in *PutRequest, opts ...grpc.CallOption) (*PutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PutResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Put_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InsertResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Insert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Upsert(ctx context.Context, in *UpsertRequest, opts ...grpc.CallOption) (*UpsertResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpsertResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Upsert_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Mutate(ctx context.Context, in *MutateRequest, opts ...grpc.CallOption) (*MutateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MutateResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Mutate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Prepare(ctx context.Context, in *PrepareRequest, opts ...grpc.CallOption) (*PrepareResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Prepare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Validate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Commit(ctx context.Context, in *CommitRequest, opts ...grpc.CallOption) (*CommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommitResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Commit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoPhaseCommitTransactionClient) Rollback(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RollbackResponse)
	err := c.cc.Invoke(ctx, TwoPhaseCommitTransaction_Rollback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TwoPhaseCommitTransactionServer is the server API for TwoPhaseCommitTransaction service.
// All implementations must embed UnimplementedTwoPhaseCommitTransactionServer
// for forward compatibility.
//
// Service that provides a two-phase commit transaction capability for ScalarDB Cluster.
// See also: https://github.com/scalar-labs/scalardb/blob/master/docs/two-phase-commit-transactions.md
//
// First, you call `Begin` to initiate a transaction if you are the coordinator process.
// Alternatively, if you are a participant process, you can call `Join` to take part in a
// transaction that the coordinator has already begun. Then, you can call `Get` and `Scan` to read
// records, `Put`, `Insert`, `Upsert`, `Update`, and `Mutate` to write records, and `Delete` and
// `Mutate` to delete records. To finalize the transaction, call `Prepare`, `Validate`, and then
// `Commit` in order. Alternatively, you can call `Rollback` at any time before the transaction is
// committed to cancel it. By calling `Begin` or `Join`, you receive a transaction ID in the
// response, which you can then use to call `Get`, `Scan`, `Put`, `Insert`, `Upsert`, `Update`,
// `Delete`, `Mutate`, `Prepare`, `Validate`, `Commit`, and `Rollback`.
//
// Also, you can call `Get`, `Scan`, `Put`, `Insert`, `Upsert`, `Update`, `Delete`, `Mutate` without
// a transaction ID. In this case, the operation is executed within a one-shot transaction.
type TwoPhaseCommitTransactionServer interface {
	// Begins a transaction.
	Begin(context.Context, *BeginRequest) (*BeginResponse, error)
	// Joins a transaction.
	Join(context.Context, *JoinRequest) (*JoinResponse, error)
	// Retrieves records.
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// Scans records.
	Scan(context.Context, *ScanRequest) (*ScanResponse, error)
	// Deprecated: Do not use.
	// Puts records.
	// This is deprecated As of release 3.13.0. Will be removed in release 5.0.0.
	Put(context.Context, *PutRequest) (*PutResponse, error)
	// Inserts records.
	Insert(context.Context, *InsertRequest) (*InsertResponse, error)
	// Upserts records.
	Upsert(context.Context, *UpsertRequest) (*UpsertResponse, error)
	// Updates records.
	Update(context.Context, *UpdateRequest) (*UpdateResponse, error)
	// Deletes records.
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// Mutates (puts, deletes, inserts, upserts, and updates) multiple records.
	Mutate(context.Context, *MutateRequest) (*MutateResponse, error)
	// Prepares a transaction.
	Prepare(context.Context, *PrepareRequest) (*PrepareResponse, error)
	// Validates a transaction.
	Validate(context.Context, *ValidateRequest) (*ValidateResponse, error)
	// Commits a transaction.
	Commit(context.Context, *CommitRequest) (*CommitResponse, error)
	// Rolls back a transaction.
	Rollback(context.Context, *RollbackRequest) (*RollbackResponse, error)
	mustEmbedUnimplementedTwoPhaseCommitTransactionServer()
}

// UnimplementedTwoPhaseCommitTransactionServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTwoPhaseCommitTransactionServer struct{}

func (UnimplementedTwoPhaseCommitTransactionServer) Begin(context.Context, *BeginRequest) (*BeginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Begin not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Join(context.Context, *JoinRequest) (*JoinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Join not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Scan(context.Context, *ScanRequest) (*ScanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scan not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Put(context.Context, *PutRequest) (*PutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Insert(context.Context, *InsertRequest) (*InsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Upsert(context.Context, *UpsertRequest) (*UpsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upsert not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Update(context.Context, *UpdateRequest) (*UpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Mutate(context.Context, *MutateRequest) (*MutateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mutate not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Prepare(context.Context, *PrepareRequest) (*PrepareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prepare not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Validate(context.Context, *ValidateRequest) (*ValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Validate not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Commit(context.Context, *CommitRequest) (*CommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) Rollback(context.Context, *RollbackRequest) (*RollbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rollback not implemented")
}
func (UnimplementedTwoPhaseCommitTransactionServer) mustEmbedUnimplementedTwoPhaseCommitTransactionServer() {
}
func (UnimplementedTwoPhaseCommitTransactionServer) testEmbeddedByValue() {}

// UnsafeTwoPhaseCommitTransactionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TwoPhaseCommitTransactionServer will
// result in compilation errors.
type UnsafeTwoPhaseCommitTransactionServer interface {
	mustEmbedUnimplementedTwoPhaseCommitTransactionServer()
}

func RegisterTwoPhaseCommitTransactionServer(s grpc.ServiceRegistrar, srv TwoPhaseCommitTransactionServer) {
	// If the following call pancis, it indicates UnimplementedTwoPhaseCommitTransactionServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TwoPhaseCommitTransaction_ServiceDesc, srv)
}

func _TwoPhaseCommitTransaction_Begin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Begin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Begin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Begin(ctx, req.(*BeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Join_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Join(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Join_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Join(ctx, req.(*JoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Scan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Scan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Scan_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Scan(ctx, req.(*ScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Put_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Put(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Put_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Put(ctx, req.(*PutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Insert(ctx, req.(*InsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Upsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Upsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Upsert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Upsert(ctx, req.(*UpsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Mutate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MutateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Mutate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Mutate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Mutate(ctx, req.(*MutateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Prepare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Prepare(ctx, req.(*PrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Validate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Validate(ctx, req.(*ValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Commit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Commit(ctx, req.(*CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TwoPhaseCommitTransaction_Rollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoPhaseCommitTransactionServer).Rollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TwoPhaseCommitTransaction_Rollback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoPhaseCommitTransactionServer).Rollback(ctx, req.(*RollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TwoPhaseCommitTransaction_ServiceDesc is the grpc.ServiceDesc for TwoPhaseCommitTransaction service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TwoPhaseCommitTransaction_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "scalardb.cluster.rpc.v1.TwoPhaseCommitTransaction",
	HandlerType: (*TwoPhaseCommitTransactionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Begin",
			Handler:    _TwoPhaseCommitTransaction_Begin_Handler,
		},
		{
			MethodName: "Join",
			Handler:    _TwoPhaseCommitTransaction_Join_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TwoPhaseCommitTransaction_Get_Handler,
		},
		{
			MethodName: "Scan",
			Handler:    _TwoPhaseCommitTransaction_Scan_Handler,
		},
		{
			MethodName: "Put",
			Handler:    _TwoPhaseCommitTransaction_Put_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _TwoPhaseCommitTransaction_Insert_Handler,
		},
		{
			MethodName: "Upsert",
			Handler:    _TwoPhaseCommitTransaction_Upsert_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _TwoPhaseCommitTransaction_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TwoPhaseCommitTransaction_Delete_Handler,
		},
		{
			MethodName: "Mutate",
			Handler:    _TwoPhaseCommitTransaction_Mutate_Handler,
		},
		{
			MethodName: "Prepare",
			Handler:    _TwoPhaseCommitTransaction_Prepare_Handler,
		},
		{
			MethodName: "Validate",
			Handler:    _TwoPhaseCommitTransaction_Validate_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _TwoPhaseCommitTransaction_Commit_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _TwoPhaseCommitTransaction_Rollback_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/scalardb/scalardb-cluster.proto",
}

const (
	DistributedTransactionAdmin_CreateNamespace_FullMethodName           = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateNamespace"
	DistributedTransactionAdmin_DropNamespace_FullMethodName             = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DropNamespace"
	DistributedTransactionAdmin_NamespaceExists_FullMethodName           = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/NamespaceExists"
	DistributedTransactionAdmin_CreateTable_FullMethodName               = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateTable"
	DistributedTransactionAdmin_DropTable_FullMethodName                 = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DropTable"
	DistributedTransactionAdmin_TruncateTable_FullMethodName             = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/TruncateTable"
	DistributedTransactionAdmin_TableExists_FullMethodName               = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/TableExists"
	DistributedTransactionAdmin_CreateIndex_FullMethodName               = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateIndex"
	DistributedTransactionAdmin_DropIndex_FullMethodName                 = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DropIndex"
	DistributedTransactionAdmin_IndexExists_FullMethodName               = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/IndexExists"
	DistributedTransactionAdmin_RepairNamespace_FullMethodName           = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/RepairNamespace"
	DistributedTransactionAdmin_RepairTable_FullMethodName               = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/RepairTable"
	DistributedTransactionAdmin_AddNewColumnToTable_FullMethodName       = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/AddNewColumnToTable"
	DistributedTransactionAdmin_CreateCoordinatorTables_FullMethodName   = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateCoordinatorTables"
	DistributedTransactionAdmin_DropCoordinatorTables_FullMethodName     = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DropCoordinatorTables"
	DistributedTransactionAdmin_TruncateCoordinatorTables_FullMethodName = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/TruncateCoordinatorTables"
	DistributedTransactionAdmin_CoordinatorTablesExist_FullMethodName    = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CoordinatorTablesExist"
	DistributedTransactionAdmin_RepairCoordinatorTables_FullMethodName   = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/RepairCoordinatorTables"
	DistributedTransactionAdmin_GetTableMetadata_FullMethodName          = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetTableMetadata"
	DistributedTransactionAdmin_GetNamespaceNames_FullMethodName         = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetNamespaceNames"
	DistributedTransactionAdmin_GetNamespaceTableNames_FullMethodName    = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetNamespaceTableNames"
	DistributedTransactionAdmin_ImportTable_FullMethodName               = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/ImportTable"
	DistributedTransactionAdmin_Upgrade_FullMethodName                   = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/Upgrade"
	DistributedTransactionAdmin_CreateUser_FullMethodName                = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateUser"
	DistributedTransactionAdmin_AlterUser_FullMethodName                 = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/AlterUser"
	DistributedTransactionAdmin_DropUser_FullMethodName                  = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DropUser"
	DistributedTransactionAdmin_Grant_FullMethodName                     = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/Grant"
	DistributedTransactionAdmin_Revoke_FullMethodName                    = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/Revoke"
	DistributedTransactionAdmin_GetUser_FullMethodName                   = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetUser"
	DistributedTransactionAdmin_GetUsers_FullMethodName                  = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetUsers"
	DistributedTransactionAdmin_GetCurrentUser_FullMethodName            = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetCurrentUser"
	DistributedTransactionAdmin_GetPrivileges_FullMethodName             = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetPrivileges"
	DistributedTransactionAdmin_CreatePolicy_FullMethodName              = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreatePolicy"
	DistributedTransactionAdmin_EnablePolicy_FullMethodName              = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/EnablePolicy"
	DistributedTransactionAdmin_DisablePolicy_FullMethodName             = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DisablePolicy"
	DistributedTransactionAdmin_GetPolicy_FullMethodName                 = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetPolicy"
	DistributedTransactionAdmin_GetPolicies_FullMethodName               = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetPolicies"
	DistributedTransactionAdmin_CreateLevel_FullMethodName               = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateLevel"
	DistributedTransactionAdmin_DropLevel_FullMethodName                 = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DropLevel"
	DistributedTransactionAdmin_GetLevel_FullMethodName                  = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetLevel"
	DistributedTransactionAdmin_GetLevels_FullMethodName                 = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetLevels"
	DistributedTransactionAdmin_CreateCompartment_FullMethodName         = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateCompartment"
	DistributedTransactionAdmin_DropCompartment_FullMethodName           = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DropCompartment"
	DistributedTransactionAdmin_GetCompartment_FullMethodName            = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetCompartment"
	DistributedTransactionAdmin_GetCompartments_FullMethodName           = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetCompartments"
	DistributedTransactionAdmin_CreateGroup_FullMethodName               = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateGroup"
	DistributedTransactionAdmin_DropGroup_FullMethodName                 = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DropGroup"
	DistributedTransactionAdmin_GetGroup_FullMethodName                  = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetGroup"
	DistributedTransactionAdmin_GetGroups_FullMethodName                 = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/getGroups"
	DistributedTransactionAdmin_SetLevelsToUser_FullMethodName           = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/SetLevelsToUser"
	DistributedTransactionAdmin_AddCompartmentToUser_FullMethodName      = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/AddCompartmentToUser"
	DistributedTransactionAdmin_RemoveCompartmentFromUser_FullMethodName = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/RemoveCompartmentFromUser"
	DistributedTransactionAdmin_AddGroupToUser_FullMethodName            = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/AddGroupToUser"
	DistributedTransactionAdmin_RemoveGroupFromUser_FullMethodName       = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/RemoveGroupFromUser"
	DistributedTransactionAdmin_DropUserTagInfoFromUser_FullMethodName   = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DropUserTagInfoFromUser"
	DistributedTransactionAdmin_GetUserTagInfo_FullMethodName            = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetUserTagInfo"
	DistributedTransactionAdmin_CreateNamespacePolicy_FullMethodName     = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateNamespacePolicy"
	DistributedTransactionAdmin_EnableNamespacePolicy_FullMethodName     = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/EnableNamespacePolicy"
	DistributedTransactionAdmin_DisableNamespacePolicy_FullMethodName    = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DisableNamespacePolicy"
	DistributedTransactionAdmin_GetNamespacePolicy_FullMethodName        = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetNamespacePolicy"
	DistributedTransactionAdmin_GetNamespacePolicies_FullMethodName      = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetNamespacePolicies"
	DistributedTransactionAdmin_CreateTablePolicy_FullMethodName         = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/CreateTablePolicy"
	DistributedTransactionAdmin_EnableTablePolicy_FullMethodName         = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/EnableTablePolicy"
	DistributedTransactionAdmin_DisableTablePolicy_FullMethodName        = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/DisableTablePolicy"
	DistributedTransactionAdmin_GetTablePolicy_FullMethodName            = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetTablePolicy"
	DistributedTransactionAdmin_GetTablePolicies_FullMethodName          = "/scalardb.cluster.rpc.v1.DistributedTransactionAdmin/GetTablePolicies"
)

// DistributedTransactionAdminClient is the client API for DistributedTransactionAdmin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service that provides comprehensive administrative operations.
type DistributedTransactionAdminClient interface {
	// Creates a namespace.
	CreateNamespace(ctx context.Context, in *CreateNamespaceRequest, opts ...grpc.CallOption) (*CreateNamespaceResponse, error)
	// Drops a namespace.
	DropNamespace(ctx context.Context, in *DropNamespaceRequest, opts ...grpc.CallOption) (*DropNamespaceResponse, error)
	// Returns whether the specified namespace exists or not.
	NamespaceExists(ctx context.Context, in *NamespaceExistsRequest, opts ...grpc.CallOption) (*NamespaceExistsResponse, error)
	// Creates a table.
	CreateTable(ctx context.Context, in *CreateTableRequest, opts ...grpc.CallOption) (*CreateTableResponse, error)
	// Drops a table.
	DropTable(ctx context.Context, in *DropTableRequest, opts ...grpc.CallOption) (*DropTableResponse, error)
	// Truncates a table.
	TruncateTable(ctx context.Context, in *TruncateTableRequest, opts ...grpc.CallOption) (*TruncateTableResponse, error)
	// Returns whether the specified table exists or not.
	TableExists(ctx context.Context, in *TableExistsRequest, opts ...grpc.CallOption) (*TableExistsResponse, error)
	// Creates an index.
	CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error)
	// Drops an index.
	DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error)
	// Returns whether the specified index exists or not.
	IndexExists(ctx context.Context, in *IndexExistsRequest, opts ...grpc.CallOption) (*IndexExistsResponse, error)
	// Repairs a namespace which may be in an unknown state.
	RepairNamespace(ctx context.Context, in *RepairNamespaceRequest, opts ...grpc.CallOption) (*RepairNamespaceResponse, error)
	// Repairs a table which may be in an unknown state.
	RepairTable(ctx context.Context, in *RepairTableRequest, opts ...grpc.CallOption) (*RepairTableResponse, error)
	// Adds a new column to a table.
	AddNewColumnToTable(ctx context.Context, in *AddNewColumnToTableRequest, opts ...grpc.CallOption) (*AddNewColumnToTableResponse, error)
	// Creates the Coordinator tables.
	CreateCoordinatorTables(ctx context.Context, in *CreateCoordinatorTablesRequest, opts ...grpc.CallOption) (*CreateCoordinatorTablesResponse, error)
	// Drops the Coordinator tables.
	DropCoordinatorTables(ctx context.Context, in *DropCoordinatorTablesRequest, opts ...grpc.CallOption) (*DropCoordinatorTablesResponse, error)
	// Truncates the Coordinator tables.
	TruncateCoordinatorTables(ctx context.Context, in *TruncateCoordinatorTablesRequest, opts ...grpc.CallOption) (*TruncateCoordinatorTablesResponse, error)
	// Returns whether the Coordinator tables exist or not.
	CoordinatorTablesExist(ctx context.Context, in *CoordinatorTablesExistRequest, opts ...grpc.CallOption) (*CoordinatorTablesExistResponse, error)
	// Repairs the Coordinator tables.
	RepairCoordinatorTables(ctx context.Context, in *RepairCoordinatorTablesRequest, opts ...grpc.CallOption) (*RepairCoordinatorTablesResponse, error)
	// Returns table metadata of the specified table.
	GetTableMetadata(ctx context.Context, in *GetTableMetadataRequest, opts ...grpc.CallOption) (*GetTableMetadataResponse, error)
	// Returns names of existing namespaces created through ScalarDB.
	GetNamespaceNames(ctx context.Context, in *GetNamespaceNamesRequest, opts ...grpc.CallOption) (*GetNamespaceNamesResponse, error)
	// Returns tables in the specified namespace.
	GetNamespaceTableNames(ctx context.Context, in *GetNamespaceTableNamesRequest, opts ...grpc.CallOption) (*GetNamespaceTableNamesResponse, error)
	// Imports an existing table that is not managed by ScalarDB.
	ImportTable(ctx context.Context, in *ImportTableRequest, opts ...grpc.CallOption) (*ImportTableResponse, error)
	// Upgrades the ScalarDB environment to support the latest version of the ScalarDB API.
	Upgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error)
	// Creates a user with the given username, password and user options.
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	// Alters a user with the given username, password and user options.
	AlterUser(ctx context.Context, in *AlterUserRequest, opts ...grpc.CallOption) (*AlterUserResponse, error)
	// Drops a user with the given username.
	DropUser(ctx context.Context, in *DropUserRequest, opts ...grpc.CallOption) (*DropUserResponse, error)
	// Grants privileges to a user.
	Grant(ctx context.Context, in *GrantRequest, opts ...grpc.CallOption) (*GrantResponse, error)
	// Revokes privileges from a user.
	Revoke(ctx context.Context, in *RevokeRequest, opts ...grpc.CallOption) (*RevokeResponse, error)
	// Returns a user.
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
	// Returns a list of users.
	GetUsers(ctx context.Context, in *GetUsersRequest, opts ...grpc.CallOption) (*GetUsersResponse, error)
	// Returns the current logged-in user.
	GetCurrentUser(ctx context.Context, in *GetCurrentUserRequest, opts ...grpc.CallOption) (*GetCurrentUserResponse, error)
	// Returns privileges for a user.
	GetPrivileges(ctx context.Context, in *GetPrivilegesRequest, opts ...grpc.CallOption) (*GetPrivilegesResponse, error)
	// Creates a policy with the given name and data tag column name.
	CreatePolicy(ctx context.Context, in *CreatePolicyRequest, opts ...grpc.CallOption) (*CreatePolicyResponse, error)
	// Enables a policy that has the given name.
	EnablePolicy(ctx context.Context, in *EnablePolicyRequest, opts ...grpc.CallOption) (*EnablePolicyResponse, error)
	// Disables a policy that has the given name.
	DisablePolicy(ctx context.Context, in *DisablePolicyRequest, opts ...grpc.CallOption) (*DisablePolicyResponse, error)
	// Retrieves a policy that has the given name.
	GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...grpc.CallOption) (*GetPolicyResponse, error)
	// Retrieves all policies.
	GetPolicies(ctx context.Context, in *GetPoliciesRequest, opts ...grpc.CallOption) (*GetPoliciesResponse, error)
	// Creates a level with the given short name, long name and level number for the given policy.
	CreateLevel(ctx context.Context, in *CreateLevelRequest, opts ...grpc.CallOption) (*CreateLevelResponse, error)
	// Drops a level that has the given short name for the given policy.
	DropLevel(ctx context.Context, in *DropLevelRequest, opts ...grpc.CallOption) (*DropLevelResponse, error)
	// Retrieves a level that has the given short name for the given policy.
	GetLevel(ctx context.Context, in *GetLevelRequest, opts ...grpc.CallOption) (*GetLevelResponse, error)
	// Retrieves all levels for the given policy.
	GetLevels(ctx context.Context, in *GetLevelsRequest, opts ...grpc.CallOption) (*GetLevelsResponse, error)
	// Creates a compartment with the given short name and long name for the given policy.
	CreateCompartment(ctx context.Context, in *CreateCompartmentRequest, opts ...grpc.CallOption) (*CreateCompartmentResponse, error)
	// Drops a compartment that has the given short name for the given policy.
	DropCompartment(ctx context.Context, in *DropCompartmentRequest, opts ...grpc.CallOption) (*DropCompartmentResponse, error)
	// Retrieves a compartment that has the given short name for the given policy.
	GetCompartment(ctx context.Context, in *GetCompartmentRequest, opts ...grpc.CallOption) (*GetCompartmentResponse, error)
	// Retrieves all compartments for the given policy.
	GetCompartments(ctx context.Context, in *GetCompartmentsRequest, opts ...grpc.CallOption) (*GetCompartmentsResponse, error)
	// Creates a group with the given short name, long name, and the short name of the parent group
	// for the given policy.
	CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error)
	// Drops a group that has the given short name for the given policy.
	DropGroup(ctx context.Context, in *DropGroupRequest, opts ...grpc.CallOption) (*DropGroupResponse, error)
	// Retrieves a group that has the given short name for the given policy.
	GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*GetGroupResponse, error)
	// Retrieves all groups for the given policy.
	GetGroups(ctx context.Context, in *GetGroupsRequest, opts ...grpc.CallOption) (*GetGroupsResponse, error)
	// Sets the given levels of the given policy to a user that has the given username.
	SetLevelsToUser(ctx context.Context, in *SetLevelsToUserRequest, opts ...grpc.CallOption) (*SetLevelsToUserResponse, error)
	// Adds the given compartment of the given policy to a user that has the given username. Before
	// adding the compartment, levels must be set to the user.
	AddCompartmentToUser(ctx context.Context, in *AddCompartmentToUserRequest, opts ...grpc.CallOption) (*AddCompartmentToUserResponse, error)
	// Removes the given compartment of the given policy from a user that has the given username.
	RemoveCompartmentFromUser(ctx context.Context, in *RemoveCompartmentFromUserRequest, opts ...grpc.CallOption) (*RemoveCompartmentFromUserResponse, error)
	// Adds the given group of the given policy to a user that has the given username. Before adding
	// the group, levels must be set to the user.
	AddGroupToUser(ctx context.Context, in *AddGroupToUserRequest, opts ...grpc.CallOption) (*AddGroupToUserResponse, error)
	// Removes the given group of the given policy from a user that has the given username.
	RemoveGroupFromUser(ctx context.Context, in *RemoveGroupFromUserRequest, opts ...grpc.CallOption) (*RemoveGroupFromUserResponse, error)
	// Drops the user tag information of a user with the given username for the given policy.
	DropUserTagInfoFromUser(ctx context.Context, in *DropUserTagInfoFromUserRequest, opts ...grpc.CallOption) (*DropUserTagInfoFromUserResponse, error)
	// Retrieves the user tag information of a user with the given username for the given policy.
	GetUserTagInfo(ctx context.Context, in *GetUserTagInfoRequest, opts ...grpc.CallOption) (*GetUserTagInfoResponse, error)
	// Creates a namespace policy with the given policy and the given namespace.
	CreateNamespacePolicy(ctx context.Context, in *CreateNamespacePolicyRequest, opts ...grpc.CallOption) (*CreateNamespacePolicyResponse, error)
	// Enables a namespace policy that has the given name.
	EnableNamespacePolicy(ctx context.Context, in *EnableNamespacePolicyRequest, opts ...grpc.CallOption) (*EnableNamespacePolicyResponse, error)
	// Disables a namespace policy that has the given name.
	DisableNamespacePolicy(ctx context.Context, in *DisableNamespacePolicyRequest, opts ...grpc.CallOption) (*DisableNamespacePolicyResponse, error)
	// Retrieves a namespace policy that has the given name.
	GetNamespacePolicy(ctx context.Context, in *GetNamespacePolicyRequest, opts ...grpc.CallOption) (*GetNamespacePolicyResponse, error)
	// Retrieves all namespace policies.
	GetNamespacePolicies(ctx context.Context, in *GetNamespacePoliciesRequest, opts ...grpc.CallOption) (*GetNamespacePoliciesResponse, error)
	// Creates a table policy with the given policy and the given table.
	CreateTablePolicy(ctx context.Context, in *CreateTablePolicyRequest, opts ...grpc.CallOption) (*CreateTablePolicyResponse, error)
	// Enables a table policy that has the given name.
	EnableTablePolicy(ctx context.Context, in *EnableTablePolicyRequest, opts ...grpc.CallOption) (*EnableTablePolicyResponse, error)
	// Disables a table policy that has the given name.
	DisableTablePolicy(ctx context.Context, in *DisableTablePolicyRequest, opts ...grpc.CallOption) (*DisableTablePolicyResponse, error)
	// Retrieves a table policy that has the given name.
	GetTablePolicy(ctx context.Context, in *GetTablePolicyRequest, opts ...grpc.CallOption) (*GetTablePolicyResponse, error)
	// Retrieves all table policies.
	GetTablePolicies(ctx context.Context, in *GetTablePoliciesRequest, opts ...grpc.CallOption) (*GetTablePoliciesResponse, error)
}

type distributedTransactionAdminClient struct {
	cc grpc.ClientConnInterface
}

func NewDistributedTransactionAdminClient(cc grpc.ClientConnInterface) DistributedTransactionAdminClient {
	return &distributedTransactionAdminClient{cc}
}

func (c *distributedTransactionAdminClient) CreateNamespace(ctx context.Context, in *CreateNamespaceRequest, opts ...grpc.CallOption) (*CreateNamespaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNamespaceResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateNamespace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DropNamespace(ctx context.Context, in *DropNamespaceRequest, opts ...grpc.CallOption) (*DropNamespaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropNamespaceResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DropNamespace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) NamespaceExists(ctx context.Context, in *NamespaceExistsRequest, opts ...grpc.CallOption) (*NamespaceExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NamespaceExistsResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_NamespaceExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreateTable(ctx context.Context, in *CreateTableRequest, opts ...grpc.CallOption) (*CreateTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTableResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DropTable(ctx context.Context, in *DropTableRequest, opts ...grpc.CallOption) (*DropTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropTableResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DropTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) TruncateTable(ctx context.Context, in *TruncateTableRequest, opts ...grpc.CallOption) (*TruncateTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruncateTableResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_TruncateTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) TableExists(ctx context.Context, in *TableExistsRequest, opts ...grpc.CallOption) (*TableExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TableExistsResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_TableExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*CreateIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateIndexResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DropIndex(ctx context.Context, in *DropIndexRequest, opts ...grpc.CallOption) (*DropIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropIndexResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DropIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) IndexExists(ctx context.Context, in *IndexExistsRequest, opts ...grpc.CallOption) (*IndexExistsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IndexExistsResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_IndexExists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) RepairNamespace(ctx context.Context, in *RepairNamespaceRequest, opts ...grpc.CallOption) (*RepairNamespaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RepairNamespaceResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_RepairNamespace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) RepairTable(ctx context.Context, in *RepairTableRequest, opts ...grpc.CallOption) (*RepairTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RepairTableResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_RepairTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) AddNewColumnToTable(ctx context.Context, in *AddNewColumnToTableRequest, opts ...grpc.CallOption) (*AddNewColumnToTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddNewColumnToTableResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_AddNewColumnToTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreateCoordinatorTables(ctx context.Context, in *CreateCoordinatorTablesRequest, opts ...grpc.CallOption) (*CreateCoordinatorTablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCoordinatorTablesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateCoordinatorTables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DropCoordinatorTables(ctx context.Context, in *DropCoordinatorTablesRequest, opts ...grpc.CallOption) (*DropCoordinatorTablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropCoordinatorTablesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DropCoordinatorTables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) TruncateCoordinatorTables(ctx context.Context, in *TruncateCoordinatorTablesRequest, opts ...grpc.CallOption) (*TruncateCoordinatorTablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TruncateCoordinatorTablesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_TruncateCoordinatorTables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CoordinatorTablesExist(ctx context.Context, in *CoordinatorTablesExistRequest, opts ...grpc.CallOption) (*CoordinatorTablesExistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CoordinatorTablesExistResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CoordinatorTablesExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) RepairCoordinatorTables(ctx context.Context, in *RepairCoordinatorTablesRequest, opts ...grpc.CallOption) (*RepairCoordinatorTablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RepairCoordinatorTablesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_RepairCoordinatorTables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetTableMetadata(ctx context.Context, in *GetTableMetadataRequest, opts ...grpc.CallOption) (*GetTableMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTableMetadataResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetTableMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetNamespaceNames(ctx context.Context, in *GetNamespaceNamesRequest, opts ...grpc.CallOption) (*GetNamespaceNamesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNamespaceNamesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetNamespaceNames_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetNamespaceTableNames(ctx context.Context, in *GetNamespaceTableNamesRequest, opts ...grpc.CallOption) (*GetNamespaceTableNamesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNamespaceTableNamesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetNamespaceTableNames_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) ImportTable(ctx context.Context, in *ImportTableRequest, opts ...grpc.CallOption) (*ImportTableResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportTableResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_ImportTable_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) Upgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpgradeResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_Upgrade_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) AlterUser(ctx context.Context, in *AlterUserRequest, opts ...grpc.CallOption) (*AlterUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AlterUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_AlterUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DropUser(ctx context.Context, in *DropUserRequest, opts ...grpc.CallOption) (*DropUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DropUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) Grant(ctx context.Context, in *GrantRequest, opts ...grpc.CallOption) (*GrantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GrantResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_Grant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) Revoke(ctx context.Context, in *RevokeRequest, opts ...grpc.CallOption) (*RevokeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_Revoke_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetUsers(ctx context.Context, in *GetUsersRequest, opts ...grpc.CallOption) (*GetUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsersResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetCurrentUser(ctx context.Context, in *GetCurrentUserRequest, opts ...grpc.CallOption) (*GetCurrentUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCurrentUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetCurrentUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetPrivileges(ctx context.Context, in *GetPrivilegesRequest, opts ...grpc.CallOption) (*GetPrivilegesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPrivilegesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetPrivileges_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreatePolicy(ctx context.Context, in *CreatePolicyRequest, opts ...grpc.CallOption) (*CreatePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreatePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) EnablePolicy(ctx context.Context, in *EnablePolicyRequest, opts ...grpc.CallOption) (*EnablePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnablePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_EnablePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DisablePolicy(ctx context.Context, in *DisablePolicyRequest, opts ...grpc.CallOption) (*DisablePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisablePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DisablePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...grpc.CallOption) (*GetPolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetPolicies(ctx context.Context, in *GetPoliciesRequest, opts ...grpc.CallOption) (*GetPoliciesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPoliciesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetPolicies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreateLevel(ctx context.Context, in *CreateLevelRequest, opts ...grpc.CallOption) (*CreateLevelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateLevelResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DropLevel(ctx context.Context, in *DropLevelRequest, opts ...grpc.CallOption) (*DropLevelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropLevelResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DropLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetLevel(ctx context.Context, in *GetLevelRequest, opts ...grpc.CallOption) (*GetLevelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLevelResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetLevels(ctx context.Context, in *GetLevelsRequest, opts ...grpc.CallOption) (*GetLevelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLevelsResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetLevels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreateCompartment(ctx context.Context, in *CreateCompartmentRequest, opts ...grpc.CallOption) (*CreateCompartmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCompartmentResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateCompartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DropCompartment(ctx context.Context, in *DropCompartmentRequest, opts ...grpc.CallOption) (*DropCompartmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropCompartmentResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DropCompartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetCompartment(ctx context.Context, in *GetCompartmentRequest, opts ...grpc.CallOption) (*GetCompartmentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCompartmentResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetCompartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetCompartments(ctx context.Context, in *GetCompartmentsRequest, opts ...grpc.CallOption) (*GetCompartmentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCompartmentsResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetCompartments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateGroupResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DropGroup(ctx context.Context, in *DropGroupRequest, opts ...grpc.CallOption) (*DropGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropGroupResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DropGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*GetGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGroupResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetGroups(ctx context.Context, in *GetGroupsRequest, opts ...grpc.CallOption) (*GetGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGroupsResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) SetLevelsToUser(ctx context.Context, in *SetLevelsToUserRequest, opts ...grpc.CallOption) (*SetLevelsToUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetLevelsToUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_SetLevelsToUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) AddCompartmentToUser(ctx context.Context, in *AddCompartmentToUserRequest, opts ...grpc.CallOption) (*AddCompartmentToUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddCompartmentToUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_AddCompartmentToUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) RemoveCompartmentFromUser(ctx context.Context, in *RemoveCompartmentFromUserRequest, opts ...grpc.CallOption) (*RemoveCompartmentFromUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveCompartmentFromUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_RemoveCompartmentFromUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) AddGroupToUser(ctx context.Context, in *AddGroupToUserRequest, opts ...grpc.CallOption) (*AddGroupToUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddGroupToUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_AddGroupToUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) RemoveGroupFromUser(ctx context.Context, in *RemoveGroupFromUserRequest, opts ...grpc.CallOption) (*RemoveGroupFromUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveGroupFromUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_RemoveGroupFromUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DropUserTagInfoFromUser(ctx context.Context, in *DropUserTagInfoFromUserRequest, opts ...grpc.CallOption) (*DropUserTagInfoFromUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DropUserTagInfoFromUserResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DropUserTagInfoFromUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetUserTagInfo(ctx context.Context, in *GetUserTagInfoRequest, opts ...grpc.CallOption) (*GetUserTagInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserTagInfoResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetUserTagInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreateNamespacePolicy(ctx context.Context, in *CreateNamespacePolicyRequest, opts ...grpc.CallOption) (*CreateNamespacePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNamespacePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateNamespacePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) EnableNamespacePolicy(ctx context.Context, in *EnableNamespacePolicyRequest, opts ...grpc.CallOption) (*EnableNamespacePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableNamespacePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_EnableNamespacePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DisableNamespacePolicy(ctx context.Context, in *DisableNamespacePolicyRequest, opts ...grpc.CallOption) (*DisableNamespacePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableNamespacePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DisableNamespacePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetNamespacePolicy(ctx context.Context, in *GetNamespacePolicyRequest, opts ...grpc.CallOption) (*GetNamespacePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNamespacePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetNamespacePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetNamespacePolicies(ctx context.Context, in *GetNamespacePoliciesRequest, opts ...grpc.CallOption) (*GetNamespacePoliciesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNamespacePoliciesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetNamespacePolicies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) CreateTablePolicy(ctx context.Context, in *CreateTablePolicyRequest, opts ...grpc.CallOption) (*CreateTablePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTablePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_CreateTablePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) EnableTablePolicy(ctx context.Context, in *EnableTablePolicyRequest, opts ...grpc.CallOption) (*EnableTablePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableTablePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_EnableTablePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) DisableTablePolicy(ctx context.Context, in *DisableTablePolicyRequest, opts ...grpc.CallOption) (*DisableTablePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableTablePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_DisableTablePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetTablePolicy(ctx context.Context, in *GetTablePolicyRequest, opts ...grpc.CallOption) (*GetTablePolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTablePolicyResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetTablePolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedTransactionAdminClient) GetTablePolicies(ctx context.Context, in *GetTablePoliciesRequest, opts ...grpc.CallOption) (*GetTablePoliciesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTablePoliciesResponse)
	err := c.cc.Invoke(ctx, DistributedTransactionAdmin_GetTablePolicies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DistributedTransactionAdminServer is the server API for DistributedTransactionAdmin service.
// All implementations must embed UnimplementedDistributedTransactionAdminServer
// for forward compatibility.
//
// Service that provides comprehensive administrative operations.
type DistributedTransactionAdminServer interface {
	// Creates a namespace.
	CreateNamespace(context.Context, *CreateNamespaceRequest) (*CreateNamespaceResponse, error)
	// Drops a namespace.
	DropNamespace(context.Context, *DropNamespaceRequest) (*DropNamespaceResponse, error)
	// Returns whether the specified namespace exists or not.
	NamespaceExists(context.Context, *NamespaceExistsRequest) (*NamespaceExistsResponse, error)
	// Creates a table.
	CreateTable(context.Context, *CreateTableRequest) (*CreateTableResponse, error)
	// Drops a table.
	DropTable(context.Context, *DropTableRequest) (*DropTableResponse, error)
	// Truncates a table.
	TruncateTable(context.Context, *TruncateTableRequest) (*TruncateTableResponse, error)
	// Returns whether the specified table exists or not.
	TableExists(context.Context, *TableExistsRequest) (*TableExistsResponse, error)
	// Creates an index.
	CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error)
	// Drops an index.
	DropIndex(context.Context, *DropIndexRequest) (*DropIndexResponse, error)
	// Returns whether the specified index exists or not.
	IndexExists(context.Context, *IndexExistsRequest) (*IndexExistsResponse, error)
	// Repairs a namespace which may be in an unknown state.
	RepairNamespace(context.Context, *RepairNamespaceRequest) (*RepairNamespaceResponse, error)
	// Repairs a table which may be in an unknown state.
	RepairTable(context.Context, *RepairTableRequest) (*RepairTableResponse, error)
	// Adds a new column to a table.
	AddNewColumnToTable(context.Context, *AddNewColumnToTableRequest) (*AddNewColumnToTableResponse, error)
	// Creates the Coordinator tables.
	CreateCoordinatorTables(context.Context, *CreateCoordinatorTablesRequest) (*CreateCoordinatorTablesResponse, error)
	// Drops the Coordinator tables.
	DropCoordinatorTables(context.Context, *DropCoordinatorTablesRequest) (*DropCoordinatorTablesResponse, error)
	// Truncates the Coordinator tables.
	TruncateCoordinatorTables(context.Context, *TruncateCoordinatorTablesRequest) (*TruncateCoordinatorTablesResponse, error)
	// Returns whether the Coordinator tables exist or not.
	CoordinatorTablesExist(context.Context, *CoordinatorTablesExistRequest) (*CoordinatorTablesExistResponse, error)
	// Repairs the Coordinator tables.
	RepairCoordinatorTables(context.Context, *RepairCoordinatorTablesRequest) (*RepairCoordinatorTablesResponse, error)
	// Returns table metadata of the specified table.
	GetTableMetadata(context.Context, *GetTableMetadataRequest) (*GetTableMetadataResponse, error)
	// Returns names of existing namespaces created through ScalarDB.
	GetNamespaceNames(context.Context, *GetNamespaceNamesRequest) (*GetNamespaceNamesResponse, error)
	// Returns tables in the specified namespace.
	GetNamespaceTableNames(context.Context, *GetNamespaceTableNamesRequest) (*GetNamespaceTableNamesResponse, error)
	// Imports an existing table that is not managed by ScalarDB.
	ImportTable(context.Context, *ImportTableRequest) (*ImportTableResponse, error)
	// Upgrades the ScalarDB environment to support the latest version of the ScalarDB API.
	Upgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error)
	// Creates a user with the given username, password and user options.
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	// Alters a user with the given username, password and user options.
	AlterUser(context.Context, *AlterUserRequest) (*AlterUserResponse, error)
	// Drops a user with the given username.
	DropUser(context.Context, *DropUserRequest) (*DropUserResponse, error)
	// Grants privileges to a user.
	Grant(context.Context, *GrantRequest) (*GrantResponse, error)
	// Revokes privileges from a user.
	Revoke(context.Context, *RevokeRequest) (*RevokeResponse, error)
	// Returns a user.
	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
	// Returns a list of users.
	GetUsers(context.Context, *GetUsersRequest) (*GetUsersResponse, error)
	// Returns the current logged-in user.
	GetCurrentUser(context.Context, *GetCurrentUserRequest) (*GetCurrentUserResponse, error)
	// Returns privileges for a user.
	GetPrivileges(context.Context, *GetPrivilegesRequest) (*GetPrivilegesResponse, error)
	// Creates a policy with the given name and data tag column name.
	CreatePolicy(context.Context, *CreatePolicyRequest) (*CreatePolicyResponse, error)
	// Enables a policy that has the given name.
	EnablePolicy(context.Context, *EnablePolicyRequest) (*EnablePolicyResponse, error)
	// Disables a policy that has the given name.
	DisablePolicy(context.Context, *DisablePolicyRequest) (*DisablePolicyResponse, error)
	// Retrieves a policy that has the given name.
	GetPolicy(context.Context, *GetPolicyRequest) (*GetPolicyResponse, error)
	// Retrieves all policies.
	GetPolicies(context.Context, *GetPoliciesRequest) (*GetPoliciesResponse, error)
	// Creates a level with the given short name, long name and level number for the given policy.
	CreateLevel(context.Context, *CreateLevelRequest) (*CreateLevelResponse, error)
	// Drops a level that has the given short name for the given policy.
	DropLevel(context.Context, *DropLevelRequest) (*DropLevelResponse, error)
	// Retrieves a level that has the given short name for the given policy.
	GetLevel(context.Context, *GetLevelRequest) (*GetLevelResponse, error)
	// Retrieves all levels for the given policy.
	GetLevels(context.Context, *GetLevelsRequest) (*GetLevelsResponse, error)
	// Creates a compartment with the given short name and long name for the given policy.
	CreateCompartment(context.Context, *CreateCompartmentRequest) (*CreateCompartmentResponse, error)
	// Drops a compartment that has the given short name for the given policy.
	DropCompartment(context.Context, *DropCompartmentRequest) (*DropCompartmentResponse, error)
	// Retrieves a compartment that has the given short name for the given policy.
	GetCompartment(context.Context, *GetCompartmentRequest) (*GetCompartmentResponse, error)
	// Retrieves all compartments for the given policy.
	GetCompartments(context.Context, *GetCompartmentsRequest) (*GetCompartmentsResponse, error)
	// Creates a group with the given short name, long name, and the short name of the parent group
	// for the given policy.
	CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error)
	// Drops a group that has the given short name for the given policy.
	DropGroup(context.Context, *DropGroupRequest) (*DropGroupResponse, error)
	// Retrieves a group that has the given short name for the given policy.
	GetGroup(context.Context, *GetGroupRequest) (*GetGroupResponse, error)
	// Retrieves all groups for the given policy.
	GetGroups(context.Context, *GetGroupsRequest) (*GetGroupsResponse, error)
	// Sets the given levels of the given policy to a user that has the given username.
	SetLevelsToUser(context.Context, *SetLevelsToUserRequest) (*SetLevelsToUserResponse, error)
	// Adds the given compartment of the given policy to a user that has the given username. Before
	// adding the compartment, levels must be set to the user.
	AddCompartmentToUser(context.Context, *AddCompartmentToUserRequest) (*AddCompartmentToUserResponse, error)
	// Removes the given compartment of the given policy from a user that has the given username.
	RemoveCompartmentFromUser(context.Context, *RemoveCompartmentFromUserRequest) (*RemoveCompartmentFromUserResponse, error)
	// Adds the given group of the given policy to a user that has the given username. Before adding
	// the group, levels must be set to the user.
	AddGroupToUser(context.Context, *AddGroupToUserRequest) (*AddGroupToUserResponse, error)
	// Removes the given group of the given policy from a user that has the given username.
	RemoveGroupFromUser(context.Context, *RemoveGroupFromUserRequest) (*RemoveGroupFromUserResponse, error)
	// Drops the user tag information of a user with the given username for the given policy.
	DropUserTagInfoFromUser(context.Context, *DropUserTagInfoFromUserRequest) (*DropUserTagInfoFromUserResponse, error)
	// Retrieves the user tag information of a user with the given username for the given policy.
	GetUserTagInfo(context.Context, *GetUserTagInfoRequest) (*GetUserTagInfoResponse, error)
	// Creates a namespace policy with the given policy and the given namespace.
	CreateNamespacePolicy(context.Context, *CreateNamespacePolicyRequest) (*CreateNamespacePolicyResponse, error)
	// Enables a namespace policy that has the given name.
	EnableNamespacePolicy(context.Context, *EnableNamespacePolicyRequest) (*EnableNamespacePolicyResponse, error)
	// Disables a namespace policy that has the given name.
	DisableNamespacePolicy(context.Context, *DisableNamespacePolicyRequest) (*DisableNamespacePolicyResponse, error)
	// Retrieves a namespace policy that has the given name.
	GetNamespacePolicy(context.Context, *GetNamespacePolicyRequest) (*GetNamespacePolicyResponse, error)
	// Retrieves all namespace policies.
	GetNamespacePolicies(context.Context, *GetNamespacePoliciesRequest) (*GetNamespacePoliciesResponse, error)
	// Creates a table policy with the given policy and the given table.
	CreateTablePolicy(context.Context, *CreateTablePolicyRequest) (*CreateTablePolicyResponse, error)
	// Enables a table policy that has the given name.
	EnableTablePolicy(context.Context, *EnableTablePolicyRequest) (*EnableTablePolicyResponse, error)
	// Disables a table policy that has the given name.
	DisableTablePolicy(context.Context, *DisableTablePolicyRequest) (*DisableTablePolicyResponse, error)
	// Retrieves a table policy that has the given name.
	GetTablePolicy(context.Context, *GetTablePolicyRequest) (*GetTablePolicyResponse, error)
	// Retrieves all table policies.
	GetTablePolicies(context.Context, *GetTablePoliciesRequest) (*GetTablePoliciesResponse, error)
	mustEmbedUnimplementedDistributedTransactionAdminServer()
}

// UnimplementedDistributedTransactionAdminServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDistributedTransactionAdminServer struct{}

func (UnimplementedDistributedTransactionAdminServer) CreateNamespace(context.Context, *CreateNamespaceRequest) (*CreateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNamespace not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DropNamespace(context.Context, *DropNamespaceRequest) (*DropNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropNamespace not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) NamespaceExists(context.Context, *NamespaceExistsRequest) (*NamespaceExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NamespaceExists not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreateTable(context.Context, *CreateTableRequest) (*CreateTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTable not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DropTable(context.Context, *DropTableRequest) (*DropTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropTable not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) TruncateTable(context.Context, *TruncateTableRequest) (*TruncateTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TruncateTable not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) TableExists(context.Context, *TableExistsRequest) (*TableExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TableExists not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreateIndex(context.Context, *CreateIndexRequest) (*CreateIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIndex not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DropIndex(context.Context, *DropIndexRequest) (*DropIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropIndex not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) IndexExists(context.Context, *IndexExistsRequest) (*IndexExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IndexExists not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) RepairNamespace(context.Context, *RepairNamespaceRequest) (*RepairNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairNamespace not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) RepairTable(context.Context, *RepairTableRequest) (*RepairTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairTable not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) AddNewColumnToTable(context.Context, *AddNewColumnToTableRequest) (*AddNewColumnToTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNewColumnToTable not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreateCoordinatorTables(context.Context, *CreateCoordinatorTablesRequest) (*CreateCoordinatorTablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCoordinatorTables not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DropCoordinatorTables(context.Context, *DropCoordinatorTablesRequest) (*DropCoordinatorTablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropCoordinatorTables not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) TruncateCoordinatorTables(context.Context, *TruncateCoordinatorTablesRequest) (*TruncateCoordinatorTablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TruncateCoordinatorTables not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CoordinatorTablesExist(context.Context, *CoordinatorTablesExistRequest) (*CoordinatorTablesExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CoordinatorTablesExist not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) RepairCoordinatorTables(context.Context, *RepairCoordinatorTablesRequest) (*RepairCoordinatorTablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairCoordinatorTables not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetTableMetadata(context.Context, *GetTableMetadataRequest) (*GetTableMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTableMetadata not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetNamespaceNames(context.Context, *GetNamespaceNamesRequest) (*GetNamespaceNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamespaceNames not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetNamespaceTableNames(context.Context, *GetNamespaceTableNamesRequest) (*GetNamespaceTableNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamespaceTableNames not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) ImportTable(context.Context, *ImportTableRequest) (*ImportTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportTable not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) Upgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Upgrade not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) AlterUser(context.Context, *AlterUserRequest) (*AlterUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlterUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DropUser(context.Context, *DropUserRequest) (*DropUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) Grant(context.Context, *GrantRequest) (*GrantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Grant not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) Revoke(context.Context, *RevokeRequest) (*RevokeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetUsers(context.Context, *GetUsersRequest) (*GetUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetCurrentUser(context.Context, *GetCurrentUserRequest) (*GetCurrentUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetPrivileges(context.Context, *GetPrivilegesRequest) (*GetPrivilegesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrivileges not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreatePolicy(context.Context, *CreatePolicyRequest) (*CreatePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) EnablePolicy(context.Context, *EnablePolicyRequest) (*EnablePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnablePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DisablePolicy(context.Context, *DisablePolicyRequest) (*DisablePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisablePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetPolicy(context.Context, *GetPolicyRequest) (*GetPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetPolicies(context.Context, *GetPoliciesRequest) (*GetPoliciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPolicies not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreateLevel(context.Context, *CreateLevelRequest) (*CreateLevelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLevel not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DropLevel(context.Context, *DropLevelRequest) (*DropLevelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropLevel not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetLevel(context.Context, *GetLevelRequest) (*GetLevelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLevel not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetLevels(context.Context, *GetLevelsRequest) (*GetLevelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLevels not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreateCompartment(context.Context, *CreateCompartmentRequest) (*CreateCompartmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCompartment not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DropCompartment(context.Context, *DropCompartmentRequest) (*DropCompartmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropCompartment not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetCompartment(context.Context, *GetCompartmentRequest) (*GetCompartmentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompartment not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetCompartments(context.Context, *GetCompartmentsRequest) (*GetCompartmentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCompartments not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DropGroup(context.Context, *DropGroupRequest) (*DropGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropGroup not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetGroup(context.Context, *GetGroupRequest) (*GetGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroup not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetGroups(context.Context, *GetGroupsRequest) (*GetGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroups not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) SetLevelsToUser(context.Context, *SetLevelsToUserRequest) (*SetLevelsToUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLevelsToUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) AddCompartmentToUser(context.Context, *AddCompartmentToUserRequest) (*AddCompartmentToUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCompartmentToUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) RemoveCompartmentFromUser(context.Context, *RemoveCompartmentFromUserRequest) (*RemoveCompartmentFromUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCompartmentFromUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) AddGroupToUser(context.Context, *AddGroupToUserRequest) (*AddGroupToUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGroupToUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) RemoveGroupFromUser(context.Context, *RemoveGroupFromUserRequest) (*RemoveGroupFromUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveGroupFromUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DropUserTagInfoFromUser(context.Context, *DropUserTagInfoFromUserRequest) (*DropUserTagInfoFromUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropUserTagInfoFromUser not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetUserTagInfo(context.Context, *GetUserTagInfoRequest) (*GetUserTagInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserTagInfo not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreateNamespacePolicy(context.Context, *CreateNamespacePolicyRequest) (*CreateNamespacePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNamespacePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) EnableNamespacePolicy(context.Context, *EnableNamespacePolicyRequest) (*EnableNamespacePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableNamespacePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DisableNamespacePolicy(context.Context, *DisableNamespacePolicyRequest) (*DisableNamespacePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableNamespacePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetNamespacePolicy(context.Context, *GetNamespacePolicyRequest) (*GetNamespacePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamespacePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetNamespacePolicies(context.Context, *GetNamespacePoliciesRequest) (*GetNamespacePoliciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNamespacePolicies not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) CreateTablePolicy(context.Context, *CreateTablePolicyRequest) (*CreateTablePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTablePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) EnableTablePolicy(context.Context, *EnableTablePolicyRequest) (*EnableTablePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableTablePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) DisableTablePolicy(context.Context, *DisableTablePolicyRequest) (*DisableTablePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableTablePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetTablePolicy(context.Context, *GetTablePolicyRequest) (*GetTablePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTablePolicy not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) GetTablePolicies(context.Context, *GetTablePoliciesRequest) (*GetTablePoliciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTablePolicies not implemented")
}
func (UnimplementedDistributedTransactionAdminServer) mustEmbedUnimplementedDistributedTransactionAdminServer() {
}
func (UnimplementedDistributedTransactionAdminServer) testEmbeddedByValue() {}

// UnsafeDistributedTransactionAdminServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DistributedTransactionAdminServer will
// result in compilation errors.
type UnsafeDistributedTransactionAdminServer interface {
	mustEmbedUnimplementedDistributedTransactionAdminServer()
}

func RegisterDistributedTransactionAdminServer(s grpc.ServiceRegistrar, srv DistributedTransactionAdminServer) {
	// If the following call pancis, it indicates UnimplementedDistributedTransactionAdminServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DistributedTransactionAdmin_ServiceDesc, srv)
}

func _DistributedTransactionAdmin_CreateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateNamespace(ctx, req.(*CreateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DropNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DropNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DropNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DropNamespace(ctx, req.(*DropNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_NamespaceExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespaceExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).NamespaceExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_NamespaceExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).NamespaceExists(ctx, req.(*NamespaceExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreateTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateTable(ctx, req.(*CreateTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DropTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DropTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DropTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DropTable(ctx, req.(*DropTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_TruncateTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TruncateTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).TruncateTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_TruncateTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).TruncateTable(ctx, req.(*TruncateTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_TableExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TableExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).TableExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_TableExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).TableExists(ctx, req.(*TableExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateIndex(ctx, req.(*CreateIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DropIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DropIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DropIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DropIndex(ctx, req.(*DropIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_IndexExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).IndexExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_IndexExists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).IndexExists(ctx, req.(*IndexExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_RepairNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).RepairNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_RepairNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).RepairNamespace(ctx, req.(*RepairNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_RepairTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).RepairTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_RepairTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).RepairTable(ctx, req.(*RepairTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_AddNewColumnToTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddNewColumnToTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).AddNewColumnToTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_AddNewColumnToTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).AddNewColumnToTable(ctx, req.(*AddNewColumnToTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreateCoordinatorTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCoordinatorTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateCoordinatorTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateCoordinatorTables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateCoordinatorTables(ctx, req.(*CreateCoordinatorTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DropCoordinatorTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropCoordinatorTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DropCoordinatorTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DropCoordinatorTables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DropCoordinatorTables(ctx, req.(*DropCoordinatorTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_TruncateCoordinatorTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TruncateCoordinatorTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).TruncateCoordinatorTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_TruncateCoordinatorTables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).TruncateCoordinatorTables(ctx, req.(*TruncateCoordinatorTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CoordinatorTablesExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CoordinatorTablesExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CoordinatorTablesExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CoordinatorTablesExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CoordinatorTablesExist(ctx, req.(*CoordinatorTablesExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_RepairCoordinatorTables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairCoordinatorTablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).RepairCoordinatorTables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_RepairCoordinatorTables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).RepairCoordinatorTables(ctx, req.(*RepairCoordinatorTablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetTableMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTableMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetTableMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetTableMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetTableMetadata(ctx, req.(*GetTableMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetNamespaceNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamespaceNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetNamespaceNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetNamespaceNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetNamespaceNames(ctx, req.(*GetNamespaceNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetNamespaceTableNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamespaceTableNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetNamespaceTableNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetNamespaceTableNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetNamespaceTableNames(ctx, req.(*GetNamespaceTableNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_ImportTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).ImportTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_ImportTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).ImportTable(ctx, req.(*ImportTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_Upgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).Upgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_Upgrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).Upgrade(ctx, req.(*UpgradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_AlterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlterUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).AlterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_AlterUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).AlterUser(ctx, req.(*AlterUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DropUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DropUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DropUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DropUser(ctx, req.(*DropUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_Grant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).Grant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_Grant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).Grant(ctx, req.(*GrantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_Revoke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).Revoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_Revoke_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).Revoke(ctx, req.(*RevokeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetUsers(ctx, req.(*GetUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetCurrentUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurrentUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetCurrentUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetCurrentUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetCurrentUser(ctx, req.(*GetCurrentUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetPrivileges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivilegesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetPrivileges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetPrivileges_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetPrivileges(ctx, req.(*GetPrivilegesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreatePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreatePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreatePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreatePolicy(ctx, req.(*CreatePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_EnablePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnablePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).EnablePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_EnablePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).EnablePolicy(ctx, req.(*EnablePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DisablePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisablePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DisablePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DisablePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DisablePolicy(ctx, req.(*DisablePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetPolicy(ctx, req.(*GetPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetPolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetPolicies(ctx, req.(*GetPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreateLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateLevel(ctx, req.(*CreateLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DropLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DropLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DropLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DropLevel(ctx, req.(*DropLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetLevel(ctx, req.(*GetLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetLevels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLevelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetLevels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetLevels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetLevels(ctx, req.(*GetLevelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreateCompartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCompartmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateCompartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateCompartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateCompartment(ctx, req.(*CreateCompartmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DropCompartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropCompartmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DropCompartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DropCompartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DropCompartment(ctx, req.(*DropCompartmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetCompartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCompartmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetCompartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetCompartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetCompartment(ctx, req.(*GetCompartmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetCompartments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCompartmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetCompartments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetCompartments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetCompartments(ctx, req.(*GetCompartmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateGroup(ctx, req.(*CreateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DropGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DropGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DropGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DropGroup(ctx, req.(*DropGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetGroup(ctx, req.(*GetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetGroups(ctx, req.(*GetGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_SetLevelsToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLevelsToUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).SetLevelsToUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_SetLevelsToUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).SetLevelsToUser(ctx, req.(*SetLevelsToUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_AddCompartmentToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCompartmentToUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).AddCompartmentToUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_AddCompartmentToUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).AddCompartmentToUser(ctx, req.(*AddCompartmentToUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_RemoveCompartmentFromUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveCompartmentFromUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).RemoveCompartmentFromUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_RemoveCompartmentFromUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).RemoveCompartmentFromUser(ctx, req.(*RemoveCompartmentFromUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_AddGroupToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGroupToUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).AddGroupToUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_AddGroupToUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).AddGroupToUser(ctx, req.(*AddGroupToUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_RemoveGroupFromUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveGroupFromUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).RemoveGroupFromUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_RemoveGroupFromUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).RemoveGroupFromUser(ctx, req.(*RemoveGroupFromUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DropUserTagInfoFromUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropUserTagInfoFromUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DropUserTagInfoFromUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DropUserTagInfoFromUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DropUserTagInfoFromUser(ctx, req.(*DropUserTagInfoFromUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetUserTagInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserTagInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetUserTagInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetUserTagInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetUserTagInfo(ctx, req.(*GetUserTagInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreateNamespacePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNamespacePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateNamespacePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateNamespacePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateNamespacePolicy(ctx, req.(*CreateNamespacePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_EnableNamespacePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableNamespacePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).EnableNamespacePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_EnableNamespacePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).EnableNamespacePolicy(ctx, req.(*EnableNamespacePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DisableNamespacePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableNamespacePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DisableNamespacePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DisableNamespacePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DisableNamespacePolicy(ctx, req.(*DisableNamespacePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetNamespacePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamespacePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetNamespacePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetNamespacePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetNamespacePolicy(ctx, req.(*GetNamespacePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetNamespacePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNamespacePoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetNamespacePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetNamespacePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetNamespacePolicies(ctx, req.(*GetNamespacePoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_CreateTablePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTablePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).CreateTablePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_CreateTablePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).CreateTablePolicy(ctx, req.(*CreateTablePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_EnableTablePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableTablePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).EnableTablePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_EnableTablePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).EnableTablePolicy(ctx, req.(*EnableTablePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_DisableTablePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableTablePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).DisableTablePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_DisableTablePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).DisableTablePolicy(ctx, req.(*DisableTablePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetTablePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTablePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetTablePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetTablePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetTablePolicy(ctx, req.(*GetTablePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedTransactionAdmin_GetTablePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTablePoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedTransactionAdminServer).GetTablePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedTransactionAdmin_GetTablePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedTransactionAdminServer).GetTablePolicies(ctx, req.(*GetTablePoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DistributedTransactionAdmin_ServiceDesc is the grpc.ServiceDesc for DistributedTransactionAdmin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DistributedTransactionAdmin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "scalardb.cluster.rpc.v1.DistributedTransactionAdmin",
	HandlerType: (*DistributedTransactionAdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNamespace",
			Handler:    _DistributedTransactionAdmin_CreateNamespace_Handler,
		},
		{
			MethodName: "DropNamespace",
			Handler:    _DistributedTransactionAdmin_DropNamespace_Handler,
		},
		{
			MethodName: "NamespaceExists",
			Handler:    _DistributedTransactionAdmin_NamespaceExists_Handler,
		},
		{
			MethodName: "CreateTable",
			Handler:    _DistributedTransactionAdmin_CreateTable_Handler,
		},
		{
			MethodName: "DropTable",
			Handler:    _DistributedTransactionAdmin_DropTable_Handler,
		},
		{
			MethodName: "TruncateTable",
			Handler:    _DistributedTransactionAdmin_TruncateTable_Handler,
		},
		{
			MethodName: "TableExists",
			Handler:    _DistributedTransactionAdmin_TableExists_Handler,
		},
		{
			MethodName: "CreateIndex",
			Handler:    _DistributedTransactionAdmin_CreateIndex_Handler,
		},
		{
			MethodName: "DropIndex",
			Handler:    _DistributedTransactionAdmin_DropIndex_Handler,
		},
		{
			MethodName: "IndexExists",
			Handler:    _DistributedTransactionAdmin_IndexExists_Handler,
		},
		{
			MethodName: "RepairNamespace",
			Handler:    _DistributedTransactionAdmin_RepairNamespace_Handler,
		},
		{
			MethodName: "RepairTable",
			Handler:    _DistributedTransactionAdmin_RepairTable_Handler,
		},
		{
			MethodName: "AddNewColumnToTable",
			Handler:    _DistributedTransactionAdmin_AddNewColumnToTable_Handler,
		},
		{
			MethodName: "CreateCoordinatorTables",
			Handler:    _DistributedTransactionAdmin_CreateCoordinatorTables_Handler,
		},
		{
			MethodName: "DropCoordinatorTables",
			Handler:    _DistributedTransactionAdmin_DropCoordinatorTables_Handler,
		},
		{
			MethodName: "TruncateCoordinatorTables",
			Handler:    _DistributedTransactionAdmin_TruncateCoordinatorTables_Handler,
		},
		{
			MethodName: "CoordinatorTablesExist",
			Handler:    _DistributedTransactionAdmin_CoordinatorTablesExist_Handler,
		},
		{
			MethodName: "RepairCoordinatorTables",
			Handler:    _DistributedTransactionAdmin_RepairCoordinatorTables_Handler,
		},
		{
			MethodName: "GetTableMetadata",
			Handler:    _DistributedTransactionAdmin_GetTableMetadata_Handler,
		},
		{
			MethodName: "GetNamespaceNames",
			Handler:    _DistributedTransactionAdmin_GetNamespaceNames_Handler,
		},
		{
			MethodName: "GetNamespaceTableNames",
			Handler:    _DistributedTransactionAdmin_GetNamespaceTableNames_Handler,
		},
		{
			MethodName: "ImportTable",
			Handler:    _DistributedTransactionAdmin_ImportTable_Handler,
		},
		{
			MethodName: "Upgrade",
			Handler:    _DistributedTransactionAdmin_Upgrade_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _DistributedTransactionAdmin_CreateUser_Handler,
		},
		{
			MethodName: "AlterUser",
			Handler:    _DistributedTransactionAdmin_AlterUser_Handler,
		},
		{
			MethodName: "DropUser",
			Handler:    _DistributedTransactionAdmin_DropUser_Handler,
		},
		{
			MethodName: "Grant",
			Handler:    _DistributedTransactionAdmin_Grant_Handler,
		},
		{
			MethodName: "Revoke",
			Handler:    _DistributedTransactionAdmin_Revoke_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _DistributedTransactionAdmin_GetUser_Handler,
		},
		{
			MethodName: "GetUsers",
			Handler:    _DistributedTransactionAdmin_GetUsers_Handler,
		},
		{
			MethodName: "GetCurrentUser",
			Handler:    _DistributedTransactionAdmin_GetCurrentUser_Handler,
		},
		{
			MethodName: "GetPrivileges",
			Handler:    _DistributedTransactionAdmin_GetPrivileges_Handler,
		},
		{
			MethodName: "CreatePolicy",
			Handler:    _DistributedTransactionAdmin_CreatePolicy_Handler,
		},
		{
			MethodName: "EnablePolicy",
			Handler:    _DistributedTransactionAdmin_EnablePolicy_Handler,
		},
		{
			MethodName: "DisablePolicy",
			Handler:    _DistributedTransactionAdmin_DisablePolicy_Handler,
		},
		{
			MethodName: "GetPolicy",
			Handler:    _DistributedTransactionAdmin_GetPolicy_Handler,
		},
		{
			MethodName: "GetPolicies",
			Handler:    _DistributedTransactionAdmin_GetPolicies_Handler,
		},
		{
			MethodName: "CreateLevel",
			Handler:    _DistributedTransactionAdmin_CreateLevel_Handler,
		},
		{
			MethodName: "DropLevel",
			Handler:    _DistributedTransactionAdmin_DropLevel_Handler,
		},
		{
			MethodName: "GetLevel",
			Handler:    _DistributedTransactionAdmin_GetLevel_Handler,
		},
		{
			MethodName: "GetLevels",
			Handler:    _DistributedTransactionAdmin_GetLevels_Handler,
		},
		{
			MethodName: "CreateCompartment",
			Handler:    _DistributedTransactionAdmin_CreateCompartment_Handler,
		},
		{
			MethodName: "DropCompartment",
			Handler:    _DistributedTransactionAdmin_DropCompartment_Handler,
		},
		{
			MethodName: "GetCompartment",
			Handler:    _DistributedTransactionAdmin_GetCompartment_Handler,
		},
		{
			MethodName: "GetCompartments",
			Handler:    _DistributedTransactionAdmin_GetCompartments_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _DistributedTransactionAdmin_CreateGroup_Handler,
		},
		{
			MethodName: "DropGroup",
			Handler:    _DistributedTransactionAdmin_DropGroup_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _DistributedTransactionAdmin_GetGroup_Handler,
		},
		{
			MethodName: "getGroups",
			Handler:    _DistributedTransactionAdmin_GetGroups_Handler,
		},
		{
			MethodName: "SetLevelsToUser",
			Handler:    _DistributedTransactionAdmin_SetLevelsToUser_Handler,
		},
		{
			MethodName: "AddCompartmentToUser",
			Handler:    _DistributedTransactionAdmin_AddCompartmentToUser_Handler,
		},
		{
			MethodName: "RemoveCompartmentFromUser",
			Handler:    _DistributedTransactionAdmin_RemoveCompartmentFromUser_Handler,
		},
		{
			MethodName: "AddGroupToUser",
			Handler:    _DistributedTransactionAdmin_AddGroupToUser_Handler,
		},
		{
			MethodName: "RemoveGroupFromUser",
			Handler:    _DistributedTransactionAdmin_RemoveGroupFromUser_Handler,
		},
		{
			MethodName: "DropUserTagInfoFromUser",
			Handler:    _DistributedTransactionAdmin_DropUserTagInfoFromUser_Handler,
		},
		{
			MethodName: "GetUserTagInfo",
			Handler:    _DistributedTransactionAdmin_GetUserTagInfo_Handler,
		},
		{
			MethodName: "CreateNamespacePolicy",
			Handler:    _DistributedTransactionAdmin_CreateNamespacePolicy_Handler,
		},
		{
			MethodName: "EnableNamespacePolicy",
			Handler:    _DistributedTransactionAdmin_EnableNamespacePolicy_Handler,
		},
		{
			MethodName: "DisableNamespacePolicy",
			Handler:    _DistributedTransactionAdmin_DisableNamespacePolicy_Handler,
		},
		{
			MethodName: "GetNamespacePolicy",
			Handler:    _DistributedTransactionAdmin_GetNamespacePolicy_Handler,
		},
		{
			MethodName: "GetNamespacePolicies",
			Handler:    _DistributedTransactionAdmin_GetNamespacePolicies_Handler,
		},
		{
			MethodName: "CreateTablePolicy",
			Handler:    _DistributedTransactionAdmin_CreateTablePolicy_Handler,
		},
		{
			MethodName: "EnableTablePolicy",
			Handler:    _DistributedTransactionAdmin_EnableTablePolicy_Handler,
		},
		{
			MethodName: "DisableTablePolicy",
			Handler:    _DistributedTransactionAdmin_DisableTablePolicy_Handler,
		},
		{
			MethodName: "GetTablePolicy",
			Handler:    _DistributedTransactionAdmin_GetTablePolicy_Handler,
		},
		{
			MethodName: "GetTablePolicies",
			Handler:    _DistributedTransactionAdmin_GetTablePolicies_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/scalardb/scalardb-cluster.proto",
}
